use crate::{Duo, Trio};

pub trait Field: Copy + Clone + std::fmt::Display + PartialEq {
    fn zero() -> Self;
    fn one() -> Self;
    fn add (x: &Self, y:& Self) -> Self;
    fn subtract (x: &Self, y:& Self) -> Self;
    fn multiply (x: &Self, y:& Self) -> Self;
    fn divide (x: &Self, y:& Self) -> Self;
    fn inv(&self) -> Self;
    fn neg(&self) -> Self;
    fn equal(x: &Self, y: &Self) -> bool;

    // derived methods. no need to implement manually.
    fn is_zero(&self) -> bool {
        Self::equal(&self, &Self::zero())
    }
    fn is_one(&self) -> bool {
        Self::equal(&self, &Self::one())
    }
}

pub trait EuclideanRing: Clone + std::fmt::Display + PartialEq {
    fn zero() -> Self;
    fn one() -> Self;
    fn add (x: &Self, y:& Self) -> Self;
    fn subtract (x: &Self, y:& Self) -> Self;
    fn multiply (x: &Self, y:& Self) -> Self;
    fn neg(&self) -> Self;
    fn equal(x: &Self, y: &Self) -> bool;
    fn norm(&self) -> usize; 
    
    // gives the result of euclidean division 
    // return value: (quotient, remainder)
    //
    // it panics if y = 0.
    fn divmod(x: &Self, y: &Self) -> Duo<Self>;

    // gives a canonical element "reg" to represent the ideal generated by self,
    // obtained by dividing a inversible element "sign".
    // The inverse of sign is also included as 3rd element, for simplicity in computation.
    // return value: (sign, reg, inv_sign)
    // This terminology is reasonable, since self = sign * g.
    // eg. -2 -> (-1, 2); 7x+14 -> (7, x+2).
    // 
    // If self is zero, it always return (zero, zero, zero).
    fn regular(&self) -> Trio<Self>; 

    // use divmod to find its inverse.
    // if the element has no inversion, then None.
    // panics if self == zero.
    fn try_inv(&self) -> Option<Self> {
        let duo = Self::divmod(&Self::one(), self);
        if duo.second == Self::zero() {
            return Some(duo.first);
        }
        None
    }

    fn is_zero(&self) -> bool {
        Self::equal(self, &Self::zero())
    }

    fn is_one(&self) -> bool {
        Self::equal(self, &Self::one())
    }

    fn gcd(input: &Duo<Self>) -> Self {
        let mut a = input.first.clone();
        let mut b = input.second.clone();
        let zero = Self::zero();
        let mut r = Self::divmod(&mut a, &mut b).second;

        while !Self::equal(&r, &zero){
            a = b.clone(); b = r.clone();
            r = Self::divmod(&mut a, &mut b).second;
        }

        b
    }

    fn recover(input: &Trio<Self>) -> Duo<Self> {
        let m = input.first.clone();
        let n = input.second.clone();
        let q = input.third.clone();

        let new_m = n.clone();
        let new_n = Self::subtract(&m, &Self::multiply(&n, &q));

        Duo::<Self>{
            first: new_m,
            second: new_n,
        }
    }

    // put in (F, G), return (U, V, H) such that FU + FV = H.
    fn bezout(input: &Duo<Self>) -> Trio<Self>{
        let mut a = input.first.clone();
        let mut b = input.second.clone();
        let zero = Self::zero();
        let one = Self::one();

        // edge cases
        if a == zero && b == zero {
            return Trio::<Self>{
                first: zero.clone(),
                second: zero.clone(),
                third: zero.clone(),
            }
        }

        if a != zero && b == zero {
            let reg = a.regular();

            return Trio::<Self> {
                first: reg.third,
                second: zero.clone(),
                third: reg.second,
            }
        }

        if a == zero && b != zero {
            let reg = b.regular();

            return Trio::<Self> {
                first: zero.clone(),
                second: reg.third,
                third: reg.second,
            }
        }

        let max_step: usize = std::cmp::max(a.norm(), b.norm()) + 1;
        let mut vec_q: Vec<Self> = vec![zero.clone(); max_step+1];

        let mut  mod_temp = Self::divmod(&a, &b);
        let mut q = mod_temp.first; let mut r = mod_temp.second;

        // edge case
        if r == zero {
            return Trio::<Self> {
                first: zero.clone(),
                second: one.clone(),
                third: b.clone(),
            }
        }

        let mut done: bool = { Self::divmod(&b, &r).second == zero };

        let mut i: usize = 1;
        vec_q[i] = q;

        while !done {
            a = b.clone();
            b = r.clone();
            
            mod_temp = Self::divmod(&a, &b);
            q = mod_temp.first;
            r = mod_temp.second;
            i += 1;
            vec_q[i] = q;

            done = Self::divmod(&b, &r).second == zero;  

        }

        let mut duo = Duo::<Self>{first: one.clone(), second: Self::neg(&vec_q[i].clone())};
        
        while i > 1 {
            let trio = Trio::<Self>{
                first: duo.first,
                second: duo.second, 
                third: vec_q[i-1].clone(),
            };
            
            duo = Self::recover(&trio);
            i -= 1;
        }

        let reg_r = r.regular();
        let monicifier = reg_r.third;

        Trio::<Self>{
            first: Self::multiply(&duo.first, &monicifier),
            second: Self::multiply(&duo.second, &monicifier),
            third: reg_r.second,
        }
    }

    fn unwrapped_bezout(f: &Self, g: &Self) -> (Self, Self, Self) {
        let res = Self::bezout(&Duo {
            first: f.clone(), second: g.clone()
        });

        (res.first, res.second, res.third)
    }
}

pub trait Ring: Clone + PartialEq {
    fn zero() -> Self;
    fn one() -> Self;
    fn add (x: &Self, y:& Self) -> Self;
    fn subtract (x: &Self, y:& Self) -> Self;
    fn multiply (x: &Self, y:& Self) -> Self;
    fn neg(&self) -> Self;
    fn equal(x: &Self, y: &Self) -> bool;
}
