use std::fmt::Display;
use customio::Parse;

pub mod arithmetic;
pub mod executable;
pub mod customio;

pub trait Field: Copy + Clone + Display + PartialEq {
    fn zero() -> Self;
    fn one() -> Self;
    fn add (x: &Self, y:& Self) -> Self;
    fn subtract (x: &Self, y:& Self) -> Self;
    fn multiply (x: &Self, y:& Self) -> Self;
    fn divide (x: &Self, y:& Self) -> Self;
    fn inv(&self) -> Self;
    fn neg(&self) -> Self;
    fn equal(x: &Self, y: &Self) -> bool;

    // derived methods. no need to implement manually.
    fn is_zero(&self) -> bool {
        Self::equal(&self, &Self::zero())
    }
    fn is_one(&self) -> bool {
        Self::equal(&self, &Self::one())
    }
}

pub trait EuclideanRing: Clone + Display + PartialEq {
    fn zero() -> Self;
    fn one() -> Self;
    fn add (x: &Self, y:& Self) -> Self;
    fn subtract (x: &Self, y:& Self) -> Self;
    fn multiply (x: &Self, y:& Self) -> Self;
    fn neg(&self) -> Self;
    fn equal(x: &Self, y: &Self) -> bool;
    fn norm(&self) -> usize; 
    
    // gives the result of euclidean division 
    // return value: (quotient, remainder)
    //
    // it panics if y = 0.
    fn divmod(x: &Self, y: &Self) -> Duo<Self>;

    // gives a canonical element "reg" to represent the ideal generated by self,
    // obtained by dividing a inversible element "sign".
    // The inverse of sign is also included as 3rd element, for simplicity in computation.
    // return value: (sign, reg, inv_sign)
    // This terminology is reasonable, since self = sign * g.
    // eg. -2 -> (-1, 2); 7x+14 -> (7, x+2).
    // 
    // If self is zero, it always return (zero, zero, zero).
    fn regular(&self) -> Trio<Self>; 

    // use divmod to find its inverse.
    // if the element has no inversion, then None.
    // panics if self == zero.
    fn try_inv(&self) -> Option<Self> {
        let duo = Self::divmod(&Self::one(), self);
        if duo.second == Self::zero() {
            return Some(duo.first);
        }
        None
    }

    fn is_zero(&self) -> bool {
        Self::equal(self, &Self::zero())
    }

    fn is_one(&self) -> bool {
        Self::equal(self, &Self::one())
    }
}

pub trait Ring: Clone + PartialEq {
    fn zero() -> Self;
    fn one() -> Self;
    fn add (x: &Self, y:& Self) -> Self;
    fn subtract (x: &Self, y:& Self) -> Self;
    fn multiply (x: &Self, y:& Self) -> Self;
    fn neg(&self) -> Self;
    fn equal(x: &Self, y: &Self) -> bool;
}

// a trivial wrapper for two elements of the same type
pub struct Duo<T> {
    pub first: T, pub second: T,
}

// a trivial wrapper for three elements of the same type
pub struct Trio<T> {
    pub first: T, pub second: T, pub third: T,
}

pub fn gcd<R>(input: &Duo<R>) -> R
where R: EuclideanRing {
    let mut a = input.first.clone();
    let mut b = input.second.clone();
    let zero = R::zero();
    let mut r = R::divmod(&mut a, &mut b).second;

    while !R::equal(&r, &zero){
        a = b.clone(); b = r.clone();
        r = R::divmod(&mut a, &mut b).second;
    }

    b
}

pub fn recover<R>(input: &Trio<R>) -> Duo<R>
where R: EuclideanRing {
    let m = input.first.clone();
    let n = input.second.clone();
    let q = input.third.clone();

    let new_m = n.clone();
    let new_n = R::subtract(&m, &R::multiply(&n, &q));

    Duo::<R>{
        first: new_m,
        second: new_n,
    }
}

pub fn bezout<R>(input: &Duo<R>) -> Trio<R>
where R: EuclideanRing {
    let mut a = input.first.clone();
    let mut b = input.second.clone();
    let zero = R::zero();
    let one = R::one();

    // edge cases
    if a == zero && b == zero {
        return Trio::<R>{
            first: zero.clone(),
            second: zero.clone(),
            third: zero.clone(),
        }
    }

    if a != zero && b == zero {
        let reg = a.regular();

        return Trio::<R> {
            first: reg.third,
            second: zero.clone(),
            third: reg.second,
        }
    }

    if a == zero && b != zero {
        let reg = b.regular();

        return Trio::<R> {
            first: zero.clone(),
            second: reg.third,
            third: reg.second,
        }
    }

    let max_step: usize = std::cmp::max(a.norm(), b.norm()) + 1;
    let mut vec_q: Vec<R> = vec![zero.clone(); max_step+1];

    let mut  mod_temp = R::divmod(&a, &b);
    let mut q = mod_temp.first; let mut r = mod_temp.second;

    // edge case
    if r == zero {
        return Trio::<R> {
            first: zero.clone(),
            second: one.clone(),
            third: b.clone(),
        }
    }

    let mut done: bool = { R::divmod(&b, &r).second == zero };

    let mut i: usize = 1;
    vec_q[i] = q;

    while !done {
        a = b.clone();
        b = r.clone();
        
        mod_temp = R::divmod(&a, &b);
        q = mod_temp.first;
        r = mod_temp.second;
        i += 1;
        vec_q[i] = q;

        done = R::divmod(&b, &r).second == zero;  

    }

    let mut duo = Duo::<R>{first: one.clone(), second: R::neg(&vec_q[i].clone())};
    
    while i > 1 {
        let trio = Trio::<R>{
            first: duo.first,
            second: duo.second, 
            third: vec_q[i-1].clone(),
        };
        
        duo = recover(&trio);
        i -= 1;
    }

    let reg_r = r.regular();
    let monicifier = reg_r.third;

    Trio::<R>{
        first: R::multiply(&duo.first, &monicifier),
        second: R::multiply(&duo.second, &monicifier),
        third: reg_r.second,
    }
}

pub fn unwrapped_bezout<R>(x: &R, y: &R) -> (R, R, R) 
where R: EuclideanRing {
    let duo = Duo::<R> {first: x.clone(), second: y.clone()};
    let trio = bezout::<R>(&duo);
    (trio.first, trio.second, trio.third)
}

